%%%% ========================= %%%%
%%%% TEST SOLVE_CABLE FUNCTION %%%%
%%%% ========================= %%%%

% %! 注意这里我们输入点坐标已经经过了变换，输入次序为:y,z,x; 点的顺序保证右手定则
% input_points = [[1.0, 0.0, 1.7320499420166016];[2.0, 0.0, 0.0]; [1.0, 0.0, -1.7320499420166016] ];
% % lengths = [1.9999992504097877, 1.4142135623730951, 1.9999992504097877];

% % 测试新的位置�??
% % lengths = [2.018247872689567, 1.2928308075455672, 1.7624516711044231];

% % 新的位置
% % lengths = [2.3657317674384704, 2.0260857942972916, 2.3105336263665954];
% %real result = [0.037257, 0.681303, 1.53775]

% % 新的位置
% lengths = [ 1.82380664,1.86055479,2.38584288,];
% %real result = [0.523799, 1.07976, 0.341499]
% %ger answer = [0.5238    1.0798    0.3415]

% %! 由于我们输入之前进行了变换，我们输出的点的次序变为了:(y,z,x)
% out_points = solve_cable(input_points, lengths)

% input_points = [[-1.0, 0.0,-1.7320499420166016];[-2.0, 0.0,0.0];[0.7838082313537598, 1.51585054397583,0.49056994915008545]];

% lengths = [1.6815809 , 2.29436869, 1.7320502914157054];
% % [-0.2669    1.2351   -0.8574]
% out_points = solve_cable(input_points, lengths)

%%%% ============================== %%%%
%%%% TEST GET_POS_POSITIVE FUNCTION %%%%
%%%% ============================== %%%%

points = [[1.7320499420166016, 1.0, 0.0];[0.0, 2.0, 0.0];[-1.7320499420166016, 1.0, 0.0];[-1.7320499420166016, -1.0, 0.0];[0.0, -2.0, 0.0];[1.7320499420166016, -1.0, 0.0]];
lengths = [1.9712469,2.00439122, 2.69899638, 1.6815809 , 2.29436869,2.13075769];
posture = get_pos_positive(points, lengths);
% 匹配blender里结�?
posture = posture*[0,1,0;-1,0,0;0,0,1]
%! matlab中表示形式不同，其输出的旋转矩阵表示的是向量的变换而不是坐标系变换？，因此求转置(逆)才是坐标系变换
posture = posture';
dcm2quat(posture)
% zyx
[az,ay,ax]=dcm2angle(posture);
rad2deg([az,ay,ax])